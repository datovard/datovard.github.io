<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="map[]" />
    <meta name="description" content="This is a personal blog for Dorian Abad Tovar Díaz">
    <link rel="shortcut icon" type="image/x-icon" href="https://datovard.github.io/img/favicon.ico">
    <title>¿Qué es el Ray-Tracing?</title>
    <meta name="generator" content="Hugo 0.26" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://datovard.github.io/css/main.css" /><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/tomorrow.min.css">
    
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old" />
    
    <!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->

    
  </head>

  <body>
    <div id="wrap">

      
      <nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://datovard.github.io/"><i class="fa fa-home"></i></a>
    </div>
    <div id="navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
        <li><a href="/blog/">BLOG</a></li>
        
        <li><a href="/projects/">PROJECTS</a></li>
        
      
      </ul>
    </div>
  </div>
</nav>

      
      <div class="container">
        <div class="blog-post">
          <h3>
            <strong><a href="https://datovard.github.io/blog/que-es-el-ray-tracing/">¿Qué es el Ray-Tracing?</a></strong>
          </h3>
        </div>
        <div class="blog-title">
          <h4>
          September 26, 2017
            &nbsp;&nbsp;
            
          </h4>
        </div>
        <div class="panel panel-default">
          <div class="panel-body">
            <div class="blogpost">
              

<h3 id="introducción"><strong>Introducción</strong></h3>

<p>En la computación gráfica actual, las escenas en tres dimensiones son algo común, y esto es necesario debido a que nosotros observamos nuestro universo en tres dimensiones, por lo que obligatorio que debamos ser capaces de representar estas escenas para que se asemejen a como visualmente percibimos lo que nos rodea.</p>

<p><center><img src="/img/Add1.jpg" style="height: 400px; align: middle;" /></center></p>

<p>Los gráficos en tres dimensiones ( gráficos 3D ) se originan por medio de grandes cálculos matemáticos sobre entidades geométricas tridimensionales producidas en computador, y su propósito es conseguir una proyección visual de la escena en 3D sobre un plano 2D como las pantallas de computador o en una impresión en papel, por lo que estos gráficos en 3D son similares a la fotografía, se plasma una escena tridimensional, en este caso, el contenido de la fotografía, sobre un plano bidimensional o la impresión de la fotografía sobre papel fotográfico.</p>

<p><center><img src="/img/Add2.jpg" style="height: 400px; margin: auto;" /></center></p>

<p>La visión humana funciona de manera que los rayos de luz que impactan sobre los objetos que nos rodean y rebotan hacia nuestro ojo representan el contenido de nuestra visión, de manera que, luego son recibidos por la retina ocular y luego la imagen es interpretada por el cerebro.</p>

<p><img src="/img/Img1.jpg" style="width: 100%;" /></p>

<p>Según ésto, ¿cómo podemos hacer que una escena computacional sea interpretada en nuestra pantalla?, imaginemos una pantalla en frente nuestro por la cual podemos visualizar una proyección de una escena en tres dimensiones ubicada al frente y limita nuestra visión únicamente a lo que esta contiene, la escena en la pantalla tiene objetos los cuales reciben rayos de luz que luego rebotan al campo de visión de la pantalla.</p>

<p><img src="/img/Img2.jpg" style="width: 100%;" /></p>

<p>Utilizar este concepto para visualizar una escena tridimensional en un computador es problemática, debido a la gran cantidad de reflexiones de rayos de luz que no llegan a la pantalla pero siguen siendo calculados, estos pueden representar una enorme cantidad de computación que es innecesaria si los rayos no son visualizados en nuestra pantalla.</p>

<p>Pero, ¿Qué pasaría si en vez de calcular todos los rayos de luz del entorno sólo calculamos aquellos rayos que nos interesa ver dentro de nuestra pantalla?, éste es el concepto principal bajo un método de renderizado ( proceso de generación de imágenes mediante el cálculo de iluminaciones ) de imágenes en computación gráfica llamado Ray-tracing, a continuación conoceremos más de este concepto.</p>

<h3 id="qué-es-el-ray-tracing"><strong>¿Qué es el Ray-tracing?</strong></h3>

<p>El Ray-tracing es una técnica para el renderizado de escenas en tres dimensiones con gran cantidad de interacciones de luz de gran complejidad. Lo que significa que podemos crear objetos como espejos, superficies transparentes y sombras con resultados asombrosos.</p>

<p><center><img src="/img/Add3.jpg" style="height: 400px; align: middle;" /></center></p>

<p>Está basada en la idea de que podemos modelar reflección y refracción siguiendo recursivamente el camino que la luz toma mientras rebota en un ambiente.</p>

<p>El Ray-tracing recibe su nombre por que trata de emular el camino que toman los rayos de luz mientras rebotan a través del ambiente, son trazados a través de la escena. El objetivo es determinar el color de cada rayo de luz que alcanza a nuestro rango de visión.</p>

<p>Como se mencionó antes, el Ray-tracing se encarga de calcular sólo aquellos rayos que sabemos que deben visualizarse en nuestra pantalla, imaginemos cualquier punto en la pantalla al cual deseamos saber de qué color debe ser para mostrar una proyección de la escena en la pantalla, el color está determinado por el rayo de luz que pasa por ese punto en la pantalla y alcanza a nuestro ojo, esto lo podemos realizar si seguimos el rayo desde el ojo, pasando por su punto en la pantalla de la proyección y alcanzando al objeto de la escena, evitando así cualquier esfuerzo perdido en calcular rayos que no visualizaremos en la proyección de la pantalla.</p>

<p><img src="/img/Img3.jpg" style="width: 100%;" /></p>

<p>Es así como el método de Ray-tracing funciona en la computación gráfica, por cada pixel que compone nuestra pantalla de proyección, emitiremos un rayo desde el ojo o punto de observación hacia el pixel en la pantalla, y luego seguiremos la misma trayectoria del rayo desde el pixel en la pantalla hacia el primer objeto en la escena con el que el rayo colisione, de esta manera, conoceremos que el color que debe tener el pixel en la proyección es el color del punto en el que colisionó nuestro rayo.</p>

<p>Luego surge un problema interesante sobre el concepto de los rayos de luz que alcanzan al ojo perceptor, ¿De dónde provienen?, debemos tener en cuenta las fuentes de estos rayos de luz y cómo estos impactan en los objetos de la escena y son reflejados hacia el ojo perceptor. Hasta este punto, no hemos considerado las emisiones de luz en nuestro esquema de Ray-tracing, pero no significa que no debamos darles importancia.</p>

<p><img src="/img/Img4.jpg" style="width: 100%;" /></p>

<p>Debemos tener en cuenta el gran número de rebotes de los rayos de luz antes de alcanzar al ojo, lo que significa que en nuestro método Ray-tracing, es posible que los rayos reboten gran cantidad de veces antes de
alcanzar a la fuente de luz, es por esto que debemos establecer algún límite en la cantidad de rebotes al seguir el rayo, tomando la siguiente aproximación: cada vez que un rayo alcanza a un objeto, seguimos a un nuevo rayo desde el punto de intersección entre el rayo anterior y el objeto hacia la fuente de luz.</p>

<h3 id="reflección-y-refracción"><strong>Reflección y Refracción</strong></h3>

<p>Si un objeto es de una superficie reflectante, el rayo que alcanza al objeto emitirá otro rayo reflectado desde el punto de intersección con el objeto, este rayo es la misma imagen del rayo reflejada en un espejo perpendicular a la superficie del objeto, pero con dirección contraria al punto de intersección, pero si el objeto tiene una superficie que de alguna manera es transparente, trazaremos un rayo de refracción en la superficie, dependiendo del material del objeto, puede poseer un indice de refracción, que curvará al rayo refractado, como por ejemplo, en superficies acuosas, pero si el mismo material está en ambas caras de la superficie, el rayo refractado viajará en la misma dirección que el rayo original</p>

<p><img src="/img/Img5.jpg" style="width: 100%;" /></p>

<p>Para calcular las direcciones de los rayos reflejados y refractados tenemos las siguientes fórmulas:</p>

<p>Por cada rayo con dirección V y una superficie con dirección perpendicular - normal - N, el rayo reflectado tiene dirección DReflejado:</p>

<pre><code>c1 = -producto_punto( N, V );
DReflejado = V + ( 2 * N * c1 );
</code></pre>

<p>Mientras que para un rayo refractado, tenemos DRefractado:</p>

<pre><code>n1 = index de refracción del medio original;
n2 = index de refracción del nuevo medio;
n = n1 / n2;
c2 = sqrt( 1 - ( n * n ) * ( 1 - ( c1 * c1 ) ) );

DRefractado = ( n * V ) + ( n * c1 - c2 ) * N;
</code></pre>

<h3 id="reflección-y-refracción-recursiva"><strong>Reflección y Refracción recursiva</strong></h3>

<p>En la figura anterior tenemos un ejemplo de objetos que son ambos reflectivos y refractivos, podemos notar que tan complicados se pueden volver los cálculos de los rayos cuando la reflección y refracción son añadidos. Cada vez que un rayo alcanza un objeto que a su vez crea dos rayos adicionales, uno reflectado y otro refractado, y que adicionalmente, cada rayo puede crear dos rayos nuevos cuando alcanza otro objeto, esto nos lleva al concepto de árbol de rayos.</p>

<p>El nodo raíz es el rayo original que parte del ojo observador y cada nodo del árbol es un rayo reflectado o refractado del rayo original, mientras que cada hoja del árbol puede ser un rayo que alcanza un objeto que no refleja ni tiene superficie transparente, por lo que no crea más rayos, o porque la máxima profundidad del árbol ha sido alcanzada.</p>

<p>Puede que esto parezca muy complicado de realizar pero, en realidad, existe un método bastante fácil para implementar este árbol de rayos, y es a partir de llamados a una función recursiva. Por cada pixel en la pantalla de visión llamaremos a la función <code>trazar_rayo()</code>, pasando como párametro el rayo desde el ojo hasta el pixel, si el primer objeto con el que el rayo colisiona no tiene una superficie reflectante o refractante, retornaremos el color en aquel punto de intersección, mientras que si esta superficie tiene algún cociente de reflección, crearemos un rayo nuevo con la dirección de reflección que calculemos para la superficie y llamaremos nuevamente a <code>trazar_rayo()</code>, aunque esta vez, pasando como parámetro el rayo reflectado, mientras que si la superficie es refractante, crearemos un rayo refractado a través del objeto y nuevamente invocaremos la función <code>trazar_rayo()</code> con el rayo refractado como parámetro. Los colores que retorna cada llamado recursivo retornan un color, el cual es combinado con el color del objeto actual y esta combinación es retornada, acá podemos observar un pseudo-código que representa esta acción:</p>

<pre><code>Color trazar_rayo( Rayo rayo_original ) {
  Color color_actual, color_reflectado, color_refractado;
  Object obj;

  // Obtenemos el primer objeto con el que el rayo intersecta
  // y el color de ese objeto
  obj = obtener_primera_interseccion( rayo_original );
  color_actual = obtener_color( obj );

  // Si el objeto tiene propiedades reflectivas, calculamos el rayo reflectado
  // Igualmente si el objeto es refractante
  if( obj es reflectivo )
    color_reflectado = trazar_rayo( obtener_rayo_reflectado( rayo_original, obj ) );
  if( obj es refractivo )
    color_refractado = trazar_rayo( obtener_rayo_refractado( rayo_original, obj ) );

  // Retornamos los colores combinados
  return ( combinar_colores( color_actual, color_reflectado, color_refractado ) );
}
</code></pre>

<h3 id="intersecciones"><strong>Intersecciones</strong></h3>

<p>Ahora debemos enfocarnos en cómo calcular la intersección de nuestro rayo con el primer objeto que encuentre, como vimos en el pseudo-código anterior, si un rayo intersecta a un objeto, la función <code>obtener_primera_interseccion()</code> retorna la distancia del punto de intersección al punto de origen del rayo y el vector normal al punto de intersección. La distancia al punto de intersección es necesario debido a que si el rayo intersecta más de un objeto, debemos escoger el punto con el punto de intersección más cercano, mientras que el vector normal es usado para determinar la sombra en aquel punto, desde que este describe en qué dirección la superficie está de frente, por lo tanto, permite observar que tanta luz afecta al punto de intersección</p>

<p>Aquí mostraré un ejemplo de intersección con una esfera, aunque deben crearse diferentes funciones de intersección para distintas figuras.</p>

<p><img src="/img/Img6.jpg" style="width: 100%;" /></p>

<p>La figura anterior muestra la geometría de un rayo <code>R</code> ( con origen <code>E</code> y dirección <code>V</code> ) intersectando a una esfera con centro <code>O</code> y radio <code>r</code>. De acuerdo al diagrama,</p>

<p><code>v²+b² = c² y d²+b² = r²</code>    (Por simple geometría)</p>

<p>también tenemos que</p>

<p><code>d = sqrt( r² - ( c² - v² ) )</code></p>

<p>Para determinar si una intersección ocurre, calcularemos el valor de <code>d</code>, si <code>d &gt;= 0</code>, entonces una intersección a ocurrido, pero si el rayo no a intersectado a la figura, <code>d</code> tendrá un valor menor a cero.</p>

<p>Luego de encontrar el valor de <code>d</code>, la distancia desde <code>E</code> al punto de intersección <code>P</code> es de <code>(v - d)</code>. El pseudo-código para esto es:</p>

<pre><code>v = producto_punto( E0, V );
disco = r² - ( producto_punto(E0, E0) - V² );
if( disco &lt; 0 )
  no hay intersección;
else
  d = sqrt( disco );
  P = E + ( v - d ) * V;
</code></pre>

<h3 id="coloreado-y-sombreado"><strong>Coloreado y Sombreado</strong></h3>

<p>Existen muchas maneras de determinar el color en un punto de intersección. Algunos métodos son realmente simples, como el Sombreado plano, donde cada punto en el objeto tiene el mismo color, mientras que algunos otros, como el método <strong>Cook-Torrance</strong>, son realmente complejos, tomando en cuenta varios atributos físicos del material en cuestión. Describiré un modelo simple conocido como <strong>sombreado Lambertino</strong> o <strong>Sombreado de coseno</strong>, que determina el brillo de un punto basado en el vector normal en el punto y el vector desde el punto a la fuente de luz. Si los dos coinciden ( la superficie enfrenta directamente la fuente de luz ) el punto estará en intensidad completa. Mientras el angulo entre los dos vectores aumenta,  como cuando la superficie se inclina hacia afuera de la luz, entonces el brillo disminuye. Conocido como el <code>Sombreado de coseno</code> debido a la función matemática implementa fácilmente el efecto: retorna 1 cuando el ángulo dado es 0, y retorna 0 cuando un ángulo de 90 grados aparece ( cuando la superficie y la fuente de luz están perpendiculares ).</p>

<p>Para encontrar el brillo de un punto, tomamos el coseno de un ángulo entre los dos vectores, este valor se calcula de manera fácil debido a que es igual al producto punto de los dos vectores de forma unitaria. Así que, tomando el producto punto de la superficie normal y el vector unitario en dirección a la luz, tenemos valores entre -1 y 1, los valores desde -1 a 0 indican que la superficie está <em>de espaldas</em> a la fuente de luz, entonces no recibe ninguna luz. Mientras que el valor de 0 significa que la superficie está directamente perpendicular a la fuente de luz, y de nuevo no recibe ninguna luz, los valores sobre 0 indican que la superficie recibe alguna luz, con máxima recepción cuando el producto punto es 1.</p>

<p>Aunque el producto punto sea cero o menor, no queremos que la parte del objeto sea totalmente negra, después de todo, incluso si el objeto está completamente bloqueado de una fuente de luz, aún hay luz rebotando que ilumina de alguna manera, por esta razón añadimos un poco de luz de ambiente a cada objeto, lo que significa que hay una mínima cantidad de luz que el objeto recibe. Si establecemos el <strong>coeficiente de ambiente</strong> a 20%, incluso en sobra total, un objeto recibe un 20% de iluminación, por ende, de alguna manera visible. Si el 20% de iluminación siempre está presente, entonces el 80% restante es determinado por el sombreado de coseno. Este 80% se conoce como el <strong>coeficiente difuso</strong>, el cual es ( 100% - coeficiente de ambiente ). El cálculo final del color es entonces:</p>

<pre><code>sombra = producto_punto( vector_iluminacion, vector_normal );
if( sombra &lt; 0 )
  sombra = 0;
color_actual = color_objeto * ( coeficiente_ambiente + coeficiente_difuso * sombra );
</code></pre>

              <hr>
              <div class="related-posts">
                <h5>Related Posts</h5>
                
              </div>
            </div>
          </div>
          <hr>
        <div class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">

    (function() {
      
      
      if (window.location.hostname == "localhost")
        return;

      var disqus_shortname = '';
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
        </div>
      </div>
      
    </div>

    
    <footer>
  <div id="footer">
    <div class="container">
      <p class="text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io/">Hugo</a> and
      <a href="http://www.github.com/nurlansu/hugo-sustain/">sustain</a> with ♥</p>
    </div>
  </div>
</footer>
<div class="footer"></div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://datovard.github.io/js/docs.min.js"></script>
<script src="https://datovard.github.io/js/main.js"></script>

<script src="https://datovard.github.io/js/ie10-viewport-bug-workaround.js"></script><!-- Syntax highlighting -->
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



    
  </body>
</html>
